<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta name=author content="Sheng-Loong Su"><meta name=description content="Generics in Scala    We can have generics in Scala through type constructors.
For example, we can have List[A] which is a type that accepts a type argument A such that A can be any types. Why do we need this? Well, this is so that we can write generic methods or functions as follows.
def doSomething[A](list: List[A], a: A): List[A] = ??? val newIntList: List[Int] = doSomething(List(1, 2, 3), 3) val newStringList: List[String] = doSomething(List(&#34;alpha&#34;, &#34;beta&#34;, &#34;delta&#34;), &#34;omicron&#34;) Note that doSomething works with List[Int] or List[String] or a List of anything for that matter."><meta name=keywords content="blog,developer,functional programming,full stack development,machine learning,deep learning,data science,big data"><meta name=twitter:card content="summary"><meta name=twitter:title content="What the F[_]? A quick introduction to Higher Kinded Types in Scala"><meta name=twitter:description content="Generics in Scala    We can have generics in Scala through type constructors.
For example, we can have List[A] which is a type that accepts a type argument A such that A can be any types. Why do we need this? Well, this is so that we can write generic methods or functions as follows.
def doSomething[A](list: List[A], a: A): List[A] = ??? val newIntList: List[Int] = doSomething(List(1, 2, 3), 3) val newStringList: List[String] = doSomething(List(&#34;alpha&#34;, &#34;beta&#34;, &#34;delta&#34;), &#34;omicron&#34;) Note that doSomething works with List[Int] or List[String] or a List of anything for that matter."><meta property="og:title" content="What the F[_]? A quick introduction to Higher Kinded Types in Scala"><meta property="og:description" content="Generics in Scala    We can have generics in Scala through type constructors.
For example, we can have List[A] which is a type that accepts a type argument A such that A can be any types. Why do we need this? Well, this is so that we can write generic methods or functions as follows.
def doSomething[A](list: List[A], a: A): List[A] = ??? val newIntList: List[Int] = doSomething(List(1, 2, 3), 3) val newStringList: List[String] = doSomething(List(&#34;alpha&#34;, &#34;beta&#34;, &#34;delta&#34;), &#34;omicron&#34;) Note that doSomething works with List[Int] or List[String] or a List of anything for that matter."><meta property="og:type" content="article"><meta property="og:url" content="https://www.codessl.com/posts/2021-12-29-what-the-f-higher-kinded-type/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-29T17:50:00+08:00"><meta property="article:modified_time" content="2021-12-29T17:50:00+08:00"><title>What the F[_]? A quick introduction to Higher Kinded Types in Scala · codessl.com</title><link rel=canonical href=https://www.codessl.com/posts/2021-12-29-what-the-f-higher-kinded-type/><link rel=preload href="https://www.codessl.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://www.codessl.com/css/coder.min.34dfa7b2f5cdeb0f5302b2628f4a7a4bfe88a2431e1397ee4ec605c56ab69701.css integrity="sha256-NN+nsvXN6w9TArJij0p6S/6IokMeE5fuTsYFxWq2lwE=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://www.codessl.com/css/coder-dark.min.aa883b9ce35a8ff4a2a5008619005175e842bb18a8a9f9cc2bbcf44dab2d91fa.css integrity="sha256-qog7nONaj/SipQCGGQBRdehCuxioqfnMK7z0Tastkfo=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=https://www.codessl.com/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://www.codessl.com/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=https://www.codessl.com/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://www.codessl.com/images/apple-touch-icon.png><meta name=generator content="Hugo 0.85.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://www.codessl.com/>codessl.com</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://www.codessl.com/about/>About</a></li><li class=navigation-item><a class=navigation-link href=https://www.codessl.com/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://www.codessl.com/posts/2021-12-29-what-the-f-higher-kinded-type/>What the F[_]? A quick introduction to Higher Kinded Types in Scala</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2021-12-29T17:50:00+08:00>December 29, 2021</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
2-minute read</span></div></div></header><div><h2 id=generics-in-scala>Generics in Scala
<a class=heading-link href=#generics-in-scala><i class="fa fa-link" aria-hidden=true></i></a></h2><p>We can have generics in Scala through type constructors.</p><p>For example, we can have <code>List[A]</code> which is a type that accepts a type argument <code>A</code> such that <code>A</code> can be any types.
Why do we need this? Well, this is so that we can write generic methods or functions as follows.</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#fff;font-weight:700>def</span> doSomething[<span style=color:#fff;font-weight:700>A</span>](list<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>List</span>[<span style=color:#fff;font-weight:700>A</span>], a<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>A</span>)<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>List</span>[<span style=color:#fff;font-weight:700>A</span>] <span style=color:#fff;font-weight:700>=</span> ???

<span style=color:#fff;font-weight:700>val</span> newIntList<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>List</span>[<span style=color:#fff;font-weight:700>Int</span>] <span style=color:#fff;font-weight:700>=</span> doSomething(List(<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>3</span>), <span style=color:#ff0;font-weight:700>3</span>)

<span style=color:#fff;font-weight:700>val</span> newStringList<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>List</span>[<span style=color:#fff;font-weight:700>String</span>] <span style=color:#fff;font-weight:700>=</span> doSomething(List(<span style=color:#0ff;font-weight:700>&#34;alpha&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;beta&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;delta&#34;</span>), <span style=color:#0ff;font-weight:700>&#34;omicron&#34;</span>)
</code></pre></div><p>Note that <code>doSomething</code> works with <code>List[Int]</code> or <code>List[String]</code> or a <code>List</code> of anything for that matter.</p><h2 id=what-is-a-higher-kinded-type-hkt>What is a Higher Kinded Type (HKT)?
<a class=heading-link href=#what-is-a-higher-kinded-type-hkt><i class="fa fa-link" aria-hidden=true></i></a></h2><p>So far, the example above is just the same old Java-esque generics.
What Scala allows us to do but Java can&rsquo;t is the capability of using Higher Kinded Types.</p><p>Generally speaking, a Higher Kinded Type is a type that abstracts over a type parameter which itself takes a type parameter.</p><h2 id=what-the-f_>What the F[_]?
<a class=heading-link href=#what-the-f_><i class="fa fa-link" aria-hidden=true></i></a></h2><p>In the example below, instead of using a concrete type like <code>List</code>, the function <code>map</code>
accepts (i) an <code>F[A]</code> and (ii) a function that transforms from <code>A</code> to <code>B</code>; and return an <code>F[B]</code>.
This means that the caller can pass in any types that accept exactly one other type,
instead of being limited to only <code>List</code></p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#fff;font-weight:700>def</span> map[<span style=color:#fff;font-weight:700>F</span>[<span style=color:#fff;font-weight:700>_</span>], <span style=color:#fff;font-weight:700>A</span>, <span style=color:#fff;font-weight:700>B</span>](a<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>F</span>[<span style=color:#fff;font-weight:700>A</span>], f<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>A</span> =&gt; B)<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>F</span>[<span style=color:#fff;font-weight:700>B</span>]

<span style=color:#fff;font-weight:700>val</span> newIntList<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>List</span>[<span style=color:#fff;font-weight:700>Int</span>] <span style=color:#fff;font-weight:700>=</span> map(List(<span style=color:#ff0;font-weight:700>1</span>,<span style=color:#ff0;font-weight:700>2</span>,<span style=color:#ff0;font-weight:700>3</span>), i <span style=color:#fff;font-weight:700>=&gt;</span> i * <span style=color:#ff0;font-weight:700>2</span>)

<span style=color:#fff;font-weight:700>val</span> newIntStream<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>Stream</span>[<span style=color:#fff;font-weight:700>Int</span>] <span style=color:#fff;font-weight:700>=</span> map((<span style=color:#ff0;font-weight:700>1</span> to <span style=color:#ff0;font-weight:700>100</span>_000_000).toStream, i <span style=color:#fff;font-weight:700>=&gt;</span> i * <span style=color:#ff0;font-weight:700>2</span>)
</code></pre></div><p>For some reason, the convention is using <code>F[_]</code> to represent the abstract type parameter
(maybe because people generally use Functor as an example to explain higher kinded types, I guess?)</p><h2 id=use-case>Use case
<a class=heading-link href=#use-case><i class="fa fa-link" aria-hidden=true></i></a></h2><p><code>F[_]</code> is heavily used in functional programming libraries like <a href=https://typelevel.org/cats/>cats</a>.
It is also often used for implementing Tagless Final (or Finally Tagless) encoding in Scala.</p><div class=highlight><pre style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#fff;font-weight:700>trait</span> Users[<span style=color:#fff;font-weight:700>F</span>[<span style=color:#fff;font-weight:700>_</span>]] {
    <span style=color:#fff;font-weight:700>def</span> getAll()<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>F</span>[<span style=color:#fff;font-weight:700>List</span>[<span style=color:#fff;font-weight:700>User</span>]]
    <span style=color:#fff;font-weight:700>def</span> getById(id<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>String</span>)<span style=color:#fff;font-weight:700>:</span> <span style=color:#fff;font-weight:700>F</span>[<span style=color:#fff;font-weight:700>Option</span>[<span style=color:#fff;font-weight:700>User</span>]]
}
</code></pre></div><p>The above is a &ldquo;Tagless Algebra&rdquo;.
You can observe that instead of returning concrete types,
the methods of an algebra return an <code>F</code> of something.
At the edge of the program, this <code>F</code> will usually be
some effect type, for example, a Cats Effect IO, a Monix Task, a ZIO.
One day I will write a blog post on Tagless Final to dive deeper into the whats, whys and hows.</p></div><footer><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//codessl.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></section></div><footer class=footer><section class=container>©
2015 -
2022
Sheng-Loong Su</section></footer></main><script src=https://www.codessl.com/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js integrity="sha256-A7F3afT5GuNWZ+HyocqMFvUFYlds+Q/zKzF5kmkU2qU="></script></body></html>